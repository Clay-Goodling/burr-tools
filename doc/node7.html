<HTML>
<HEAD>
<TITLE>Defining Puzzles</TITLE>
</HEAD>

<BODY >
<B>Next:</B> <A NAME="tex2html485" HREF="node8.html">Solving Puzzles</A>
<B>Up:</B> <A NAME="tex2html481" HREF="node3.html">User Guide</A>
<B>Previous:</B> <A NAME="tex2html475" HREF="node6.html">Creating Shapes</A>
&nbsp;<B><A NAME="tex2html483" HREF="node1.html">Contents</A></B> 
<HR>
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
  <LI><A NAME="tex2html486" HREF="node7.html#SECTION02410000000000000000">Defining Simple Problems</A>
  <UL>
    <LI><A NAME="tex2html487" HREF="node7.html#SECTION02411000000000000000">Initialising Problems</A>
    <LI><A NAME="tex2html488" HREF="node7.html#SECTION02412000000000000000">Piece Assignment</A>
  </UL>
  <BR>
  <LI><A NAME="tex2html489" HREF="node7.html#SECTION02420000000000000000">Piece Ranges</A>
  <LI><A NAME="tex2html490" HREF="node7.html#SECTION02430000000000000000">Grouping Pieces</A>
  <UL>
    <LI><A NAME="tex2html491" HREF="node7.html#SECTION02431000000000000000">Concept</A>
    <UL>
      <LI><A NAME="tex2html492" HREF="node7.html#SECTION02431100000000000000">Complete Disassembly</A>
      <LI><A NAME="tex2html493" HREF="node7.html#SECTION02431200000000000000">Basic Piece Grouping</A>
      <LI><A NAME="tex2html494" HREF="node7.html#SECTION02431300000000000000">Grouping Multipieces</A>
      <LI><A NAME="tex2html495" HREF="node7.html#SECTION02431400000000000000">Example</A>
    </UL>
  </UL>
  <BR>
  <LI><A NAME="tex2html496" HREF="node7.html#SECTION02440000000000000000">Editing Problem Details</A>
  <LI><A NAME="tex2html497" HREF="node7.html#SECTION02450000000000000000">Setting Colour Constraints</A>
  <LI><A NAME="tex2html498" HREF="node7.html#SECTION02460000000000000000">Managing Problems</A>
  <LI><A NAME="tex2html499" HREF="node7.html#SECTION02470000000000000000">Tips and Tricks</A>
  <UL>
    <LI><A NAME="tex2html500" HREF="node7.html#SECTION02471000000000000000">Grouping Tips</A>
    <LI><A NAME="tex2html501" HREF="node7.html#SECTION02472000000000000000">Constraint Tips</A>
  </UL>
</UL>
<HR>

<H1><A NAME="SECTION02400000000000000000"></A><A NAME="ChapterPuzzles"></A><BR>Defining Puzzles</H1>
  
<P>
Typically a puzzle problem in B<SMALL>URR</SMALL>T<SMALL>OOLS</SMALL> consists of a collection
  of pieces (shapes) and a goal, say another shape that the pieces should form
  when correctly assembled. This is what we call a <EM>simple problem
  definition</EM>. Note that it may well be not that 'simple' to solve it in real
  life. More elaborated or <EM>complex puzzle problems</EM> contain also
  colour constraints and/or grouped pieces.

<P>
As stated before, a puzzle can be a collection of problems, either simple,
  complex or a mixture of both. The <I><B>Puzzle</B></I> tab
  (Figure <A HREF="#FigurePuzzleTab">PuzzleTab</A>) provides all the tools needed to build a
  variety of puzzle problems that are suited for the <I>Solver</I>.
  
<CENTER>
<A NAME="FigurePuzzleTab"></A><A NAME="1676"></A>
<IMG SRC="Window_DDD_2.png"><BR>
<STRONG>Figure:</STRONG>Defining problems on the Puzzle tab
</CENTER>

<H1><A NAME="SECTION02410000000000000000">Defining Simple Problems</A></H1>

<P>
As defined above, a simple puzzle problem consists only of a collection of
  pieces and a result shape that can be assembled (and preferably also
  disassembled) with these pieces (Figure <A HREF="#FigureSimplePuzzleProblem">SimplePuzzleProblem</A>).
  Bear in mind that a simple problem also implies that <EM>all</EM> the pieces
  can be separated from one another. It takes only two steps (which are also
  required for complex problems) to create such a problem:
  <EM>initialising</EM> the problem and <EM>assigning</EM> shapes to the
  pieces and the result.

<H2><A NAME="SECTION02411000000000000000"></A><A NAME="InitialisingProblems"></A>Initialising Problems</H2>

<P>
The first step is to <EM>initialise</EM> the problem(s). All the tools to do
  so are just below the <I><B>Problems</B></I> caption. Just as with
  shapes, this can be done by clicking the <I><B>New</B></I> button
  to start a completely new one, or by using <I><B>Copy</B></I> to
  edit a previously created problem definition without destroying the
  original. Accordingly, problems can be removed with the
  <I><B>Delete</B></I> button. All problems find their place in the
  problems list below these buttons and are identified with a
  '<I><B>P<EM>x</EM></B></I>' prefix to which a more meaningful
  description can be added by clicking the <I><B>Label</B></I>
  button. Also the methods for selecting and rearranging problems are similar
  to their counterparts on the <I>Entities</I> tab and need no further
  explanation here.

<H2><A NAME="SECTION02412000000000000000"></A><A NAME="PieceAssignment"></A>Piece Assignment</H2>

<P>
Until now we dealt with shapes as rather abstract concepts. Only by
  <EM>assigning</EM> these shapes to the pieces or the goal of a puzzle do
  they become meaningful. All available shapes are presented in the top list
  of the <I><B>Piece Assignment</B></I> panel, in which they can be
  selected and be given their purpose in the puzzle. Since a strict
  distinction is made between shapes and pieces, it's not necessary that all
  shapes be used in a single problem or in any problem at all.

<CENTER>
<A NAME="FigureSimplePuzzleProblem"></A><A NAME="1689"></A>
<IMG SRC="Window_Clarissa.png"><BR>
<STRONG>Figure:</STRONG>A simple puzzle problem with multipieces
</CENTER>

<P>

Although not mandatory, it's probably best to assign the result
  shape first: select the appropriate shape and click <I><B>Set
  Result</B></I>. The result shape is then depicted in the top left part of the
  3-D viewport (which also shows a smaller example of the currently
  selected shape) and the status line shows some information about the problem
  at hand.

<P>
Next, any other shape can be assigned to the pieces of the puzzle by
  selecting it and clicking <I><B>+1</B></I>. This adds a single
  copy of the shape to the second list which holds all the shapes used as
  pieces. If multipieces are involved, just add as many instances of the shape
  as required by the same means.

<P>
In the list of pieces any multipiece has an instance counter added (in
  parentheses) to its identifier. A single instance of every shape used in the
  puzzle is shown in the lower part of the 3-D viewer. To make
  corrections, pieces can be removed from the puzzle by selecting them (they
  also can be selected by clicking them in the pieces list) and clicking
  <B><I>-1</I></B>. Again, this removes only a single
  instance and needs to be repeated for removing multipieces.

<P>
Most of the time it is necessary to add one instance of all defined shapes
  to the puzzle. If there are a lot of them this can take while. This is what
  the <I><B>all +1</B></I> button is for. It increases the piece
  counter for each shape (except the one assigned for the result) by one. Or
  it adds a first instance of the shape to the problem. The
  <I><B>Clr</B></I> button removes all pieces from the problem.

<P>
Since it doesn't make sense for any shape to be both the result and a piece
  at the same time, the shape set as result cannot be added to the list of
  pieces. Consequently, assigning a shape that's already in the list of pieces
  to the result will remove it from the list.

<P>
Whenever the total number of cubes in the pieces is within the boundaries
  set by the result shape (which can be inspected on the status line), this
  kind of simple puzzle problems can be taken to the solver. Note that the
  solver won't run if one or more pieces contain any variable voxels.

<H1><A NAME="SECTION02420000000000000000">Piece Ranges</A></H1>

<P>
B<SMALL>URR</SMALL>T<SMALL>OOLS</SMALL> is capable of handling piece ranges instead of a fixed
  number of pieces. This feature is useful when you want to search for puzzles
  instead of solving a given one. If there is a range defined for one or more
  pieces then B<SMALL>URR</SMALL>T<SMALL>OOLS</SMALL> finds all ways to assemble the defined
  result using a number of pieces within the given range. As an example let's
  take Ronald Kint-Bruynseels Clarissa-Burr (see
  <TT>http://www.asahi-net.or.jp/~ rh5k-isn/Puzzle/ClarissaBurr</TT>).
  This puzzle consists of 2 different shapes. When Ronald defined this puzzle
  he had to try all possible combinations of the 2 pieces, beginning with 6
  pieces of shape A and zero of shape B, over 5 times A and one B up to 6
  times B. This can now be done way more easily with piece ranges. Simply tell
  B<SMALL>URR</SMALL>T<SMALL>OOLS</SMALL> that the result should be made out of 0-6 pieces of
  shape A and 0-6 pieces of shape B, or if you want to ensure that at least
  one of each shape is used, use ranges 1-6. Then solve.

<P>
Piece ranges can be easily defined using the <I><B>min=0</B></I>
  button. This will set the minimum of the piece range for the current shape
  to zero. With that you can define the range by first adding max-min
  pieces (meaning the difference between the maximum and the minimum number of
  pieces), then set the minimum to zero and then add the missing min
  pieces. This should cover the most used usage cases.

<P>
For example: suppose you want to add a piece that you want to use 3, 4, 5 or
  6 times in your puzzle. The piece range is 3-6. To enter those values you
  first add 6-3=3
 pieces. Then you press the <I><B>min=0</B></I>
  button getting a piece range 0-3. Now you add another 3 pieces and you get
  the range you want.

<P>
Except for the <I><B>min=0</B></I> button, all other buttons always
  change the minimum and the maximum of the piece range.

<P>
If this calculation is too hard for you, you can use the problem detail
  dialogue (see section <A HREF="#SectionProblemDetails">ProblemDeatils</A>) to enter the ranges
  directly without the need for calculations.

<H1><A NAME="SECTION02430000000000000000">Grouping Pieces</A></H1>

<P>
Something we deliberately haven't mentioned in the description above is the
  fact that the solver will halt whenever it is unable to separate some pieces
  from each other. In other words, the solver will attempt to separate
  <EM>all</EM> the pieces from each other and reports that no solution exists
  when it fails to do so. This is just what is required for most puzzles as
  you need to have single pieces as a starting point.

<P>
But there are a few puzzles for which you have groups of pieces that are
  <EM>movable</EM> but <EM>not separable</EM>. Here the piece groups come in
  handy. Probably everyone familiar with P<SMALL>UZZLE</SMALL>S<SMALL>OLVER3</SMALL>D ever
  experienced the futile attempts of that program trying to solve such designs
  by nearly endlessly shifting the entangled pieces back and forth. Not so
  with B<SMALL>URR</SMALL>T<SMALL>OOLS</SMALL>, as piece groups allow you to tell the
  disassembler that it is OK when it cannot separate a few pieces from one
  another.

<H2><A NAME="SECTION02431000000000000000">Concept</A></H2>

<P>
When the disassembler finds two or more pieces that cannot be taken apart it
  checks whether all of the pieces involved are in the same group. If that's
  the case it rests assured and continues. If the pieces are <EM>not</EM> in
  the same group, the disassembler aborts its work and reports that the
  assembly cannot be disassembled. This is the basic idea, but there is a bit
  more to it.

<H3><A NAME="SECTION02431100000000000000">Complete Disassembly</A></H3>

<P>
A special case is <EM>'Group-0'</EM>. All pieces in this group
  <EM>need to be separated</EM> from each other. This group is included so
  that it is not necessary to place all the pieces into their own group when
  you want the puzzle to completely disassemble. Pieces automatically go into
  Group-0, so you don't need to take care of that. As a matter of
  fact you won't even find any reference to that Group-0 in the GUI.

<H3><A NAME="SECTION02431200000000000000">Basic Piece Grouping</A></H3>

<P>
On the other hand, when dealing with puzzles of which it is known that
  certain pieces (say S<EM>a</EM> and S<EM>b</EM>) can't be separated from
  each other, grouping these pieces will cause the solver to report a valid
  disassembly in which the grouped pieces are treated as a single piece. But
  it is not a rigid piece since the parts can freely (within certain
  boundaries) move with respect to each other.

<P>
<CENTER>
{S<EM>a</EM>, S<EM>b</EM>}
</CENTER>

<P>
<CENTER>
Group-1 &rarr; S<EM>a</EM>+S<EM>b</EM>
</CENTER>

<P>
This technique can also be used for pieces that may be entangled, in case
  one is searching for possible designs. If these pieces are indeed
  inseparable the solver will report so, but if they can be separated the
  solver may report the complete disassembly as well:

<P>
<CENTER>
{S<EM>a</EM>, S<EM>b</EM>} ?
</CENTER>

<P>
<CENTER>
Group-1 &rarr; S<EM>a</EM>+S<EM>b</EM>
</CENTER>

<P>
<CENTER>
Result: {S<EM>a</EM>, S<EM>b</EM>} and/or S<EM>a</EM>, S<EM>b</EM>
</CENTER>

<P>
Now for the hard part: <EM>pieces can be in more than one group</EM>. If you
  have e.g. a puzzle for which you know that piece S<EM>a</EM> either
  interlocks with piece S<EM>b</EM> or piece S<EM>c</EM> and cannot be
  separated from it, but you don't know which of those (S<EM>b</EM> or
  S<EM>c</EM>) piece S<EM>a</EM> is attached to, you can assign
  Group-1 to S<EM>a</EM>+S<EM>b</EM> and Group-2 to
  S<EM>a</EM>+S<EM>c</EM>:

<P>
<CENTER>
{S<EM>a</EM>, S<EM>b</EM>} or {S<EM>a</EM>, S<EM>c</EM>}
</CENTER>

<P>
<CENTER>
Group-1 &rarr; S<EM>a</EM>+S<EM>b</EM>
</CENTER>

<P>
<CENTER>
Group-2 &rarr; S<EM>a</EM>+S<EM>c</EM>
</CENTER>

<P>
This way the disassembler detects that both pieces are in Group-1
  when S<EM>a</EM> and S<EM>b</EM> are inseparable and it finds that both
  pieces are in Group-2 when S<EM>a</EM> and S<EM>c</EM> cannot let
  go from each other. In both cases the solver will report a valid
  disassembly. However, if S<EM>b</EM> and S<EM>c</EM> are entangled the
  solver is not able to find a valid disassembly.

<H3><A NAME="SECTION02431300000000000000">Grouping Multipieces</A></H3>

<P>
All instances of a multipiece need to have the same group assignment, but
  you can specify how many of these may be in a group <EM>maximally</EM>. That
  means you can make statements like 'not more than 3 pieces of S<EM>n</EM>
  <EM>may</EM> be in Group-1':

<P>

<CENTER>
S<EM>a_1</EM>, S<EM>a_2</EM>, ... S<EM>a_n</EM>
</CENTER>

<P>
<CENTER>
Group-1 &rarr; S<EM>a_1</EM>+S<EM>a_2</EM>+S<EM>a_3</EM>
</CENTER>

<P>
Now how does it all come together? The disassembler starts to do its work.
  For each subproblem (a subproblem is a few pieces that it somehow has to get
  apart) it first checks if there is a unique group assignment for all pieces
  involved - i.e. all pieces have exactly one group assigned and that group
  is the same for all of them - it doesn't even attempt to disassemble that
  subproblem.

<P>
If this is not the case it tries to disassemble. In case of a failure it
  adds the pieces that are in this subproblem to a table of lists of pieces.
  Once done with the disassembler, the program comes back to this table and
  tries to assign a group to each of the lists of pieces. It just checks all
  possibilities by comparing the entries of the table with the group
  assignments made by the user. Whenever the sum of pieces (of a certain shape
  S<EM>x</EM>) in such a 'problematic' table entry is bigger than the value
  the user designated to that particular piece, no valid group assignment can
  be made. If the program can find a valid assignment the puzzle is
  disassembled; if it cannot, the puzzle is assumed to be not disassemblable.

<P>

<H3><A NAME="SECTION02431400000000000000">Example</A></H3>

<P>
Assume we have a puzzle that contains (among others) 5 pieces of shape
  S<EM>a</EM>. Three of them might go into Group-1 and another 2
  into Group-2. There is also a piece S<EM>b</EM> that might go into
  Group-1:

<P>
<CENTER>
Group-1 &rarr; S<EM>a_1</EM>+S<EM>a_2</EM>+S<EM>a_3</EM>+S<EM>b</EM>
</CENTER>

<P>
<CENTER>
Group-2 &rarr; S<EM>a_1</EM>+S<EM>a_2</EM>
</CENTER>

<P>
After the disassembler has run we have the following lists of pieces in the table:

<OL>
<LI>S<EM>a</EM>, S<EM>a</EM>
<LI>S<EM>a</EM>, S<EM>a</EM>, S<EM>b</EM>
</OL>
 Now the program has to assign Group-2 to the first set of pieces
  and Group-1 to the second set of pieces. Because otherwise piece
  S<EM>b</EM> would be in the wrong group, it can only be in
  Group-1. If there would be another piece S<EM>a</EM> in the first
  set it would not be possible to assign groups because we can only have two
  pieces S<EM>a</EM> in Group-2. But it would be possible to have
  another piece S<EM>a</EM> in the second set.

<P>
We have no idea how useful this might be in practice as most of the
  currently available puzzles require a complete disassembly. But who knows,
  maybe this feature will help in the design of lots of puzzles new and crazy
  ideas.

<H1><A NAME="SECTION02440000000000000000"></A><A NAME="SectionProblemDetails"></A>Editing Problem Details</H1>

<P>
All settings that cannot be set directly on the main problem tab can be set
  within the <I><B>Problem Details</B></I> window
  (Figure
 <A HREF="#FigureGroupEditor">GroupEditor</A>) which opens by clicking the
  <I><B>Detail</B></I> button. This window allows you to define groups
  and to define piece ranges without having to subtract values. The window
  also contains rarely-used parameters.
  
<CENTER>
<A NAME="FigureGroupEditor"></A><A NAME="1777"></A>
<IMG SRC="Form_Group_Editor.png"><BR>
<STRONG>Figure:</STRONG>The Problem Details Editor
</CENTER>

<P>
Let's first see how piece groups are defined using this window. Although the
  above section may sound complicated, implementing piece groups is actually
  very simple. All actions take place in the <I><B>Problem
  Details Editor</B></I>. Initially the <I>Group Editor</I> shows a tabulated
  overview of the pieces used in the problem. The first column
  (<I>Shape</I>) lists the pieces by their prefix and name, the second and
  third (<I>min</I> and <I>max</I>) show the instances range of each.

<P>
Creating piece groups is straightforward as the <I><B>Add
  Group</B></I> button simply adds a new group to the problem. Each new group gets
  its own column (<I>Gr 1</I>, <I>Gr 2</I>, etc...) in which one can
  specify the <EM>maximum</EM> number of instances of a certain piece that can
  go in that particular group. Just click on a cell and it will become an
  input box. Cells that contain a value&nbsp;&gt;&nbsp;0 will receive the default colour of
  the corresponding shape, cells with zero are grey and no number is shown.
  Any group that has no values at all in its column will be deleted on closing
  the <I>Group Editor</I>. Hence, deleting all the values of a previously
  made group will remove the group even if its column stays present in the
  <I>Group Editor</I>.

<P>
Now to the piece ranges. It is possible to enter the values directly into
  the min and max columns of the table. You just have to keep in mind, that
  min has to be less than or equal to max. This is enforced by the program, so
  that max will change, if you enter a value in min that is larger than the
  current maximum. The same holds true for the minimum, when changing the
  value in the max column. You also need to keep in mind that the table
  contains entries only for shapes that are already used in the current
  problem. You cannot (yet) add another shape to the problem using this
  dialogue, but you can remove a shape by setting the minimum and the maximum
  to zero.

<P>
Finally, this window also contains an entry field called
  <I><B>Maximum Number of Holes</B></I> (empty variable cubes). This
  value is used by the program, when piece ranges are used, in which case it
  is not possible for the program to determine many holes there will be in the
  final solution. Because this missing information results in a huge slowdown
  as many more possibilities have to be tried, it is possible to use this
  field to specify the maximum number of holes allowed. If the number of holes
  should not be limited, the field should be left empty.

<H1><A NAME="SECTION02450000000000000000"></A><A NAME="ColourConstraints"></A>Setting Colour Constraints</H1>

<P>
B<SMALL>URR</SMALL>T<SMALL>OOLS</SMALL> automatically adds the most probable rules for colour
  constraint when you add a new colour or when a new problem is created,
  namely that each colour can be mapped into itself, i.e. a piece voxel with
  colour C<I>x</I> can go into a result voxel of colour C<I>x</I>. If
  you don't want that or if you need additional placement possibilities, you
  can change the colour constraint rules in the colour assignment section.

<P>
The <B><I>Colour Assignment</I></B> panel
  (Figure <A HREF="#FigureColourAssignment">ColourAssignment</A>) has two lists. The first one
  shows all the available custom colours and allows selecting a certain colour
  for which then some relations can be set. These relations simply indicate
  which colour(s) in the result can accommodate which colour(s) in the pieces.
  By allowing certain combinations (which is in fact prohibiting all other
  combinations), constraints are imposed on the possible placements of the
  pieces. These relationships are shown and constructed in the second list.
  This list has three columns, of which the first shows the 'piece colours',
  the last shows the 'result colours', and the one in between clearly depicts
  the relationships by a series of arrows pointing from the piece colours to
  the result colours. The list is sorted either by the piece colours or by the
  result colours. The buttons <I><B>Sort by Piece</B></I> and
  <I><B>Sort by Result</B></I> switch between these two views.
  
<CENTER>
<A NAME="FigureColourAssignment"></A><A NAME="1785"></A>
<IMG SRC="Panel_Colour_Assignment_A.png">
<IMG SRC="Panel_Colour_Assignment_B.png"><BR>
<STRONG>Figure:</STRONG>Colour assignment
</CENTER>

<P>
When <EM>sorted by piece</EM> (the left part of Figure
  <A HREF="#FigureColourAssignment">ColourAssignment</A>), the bottom list is showing you that every
  voxel of the pieces with colour C<EM>x</EM> can go into every voxel of the
  result that has one of the colours at the end points of the arrows starting
  from Cx. When <EM>sorted by result</EM> (on the right in Figure
  <A HREF="#FigureColourAssignment">ColourAssignment</A>), the list shows which piece colours will be
  allowed to go in a particular colour of the result.

<P>
To set these relationships, first click the piece colour (or result colour,
  depending on the sorting method) for which you want to set the constraints.
  This will activate the 'relations line' for that particular colour which is
  indicated with a dark surrounding box (note that clicking anywhere on this
  relations line has the same effect). Next, the down and up pointing arrows
  will respectively add or remove the colour selected in the top list to or
  from the constraint settings.

<H1><A NAME="SECTION02460000000000000000">Managing Problems</A></H1>

<P>
Currently puzzle problems can  be rearranged only with the left and right
  arrow buttons of the <I>Problems</I> section, but more advanced
  management procedures may be added in the future.

<P>

<H1><A NAME="SECTION02470000000000000000">Tips and Tricks</A></H1>

<P>
<DL>
<DT><STRONG>Maximum Number of Holes </STRONG></DT>
<DD>Keep this value as small as possible,
    because the more holes a puzzle contains the longer the solving will take.
    Normally the value is undefined, meaning the number of holes is
    <EM>not</EM> limited. So if you know the number of holes you want, or you
    want to limit them, or the solving takes too long, use this field.
</DD>
</DL>
<P>
Some tricks and tips will be added to the next update of the user guide.

<H2><A NAME="SECTION02471000000000000000">Grouping Tips</A></H2>

<H2><A NAME="SECTION02472000000000000000">Constraint Tips</A></H2>

<HR>
<B>Next:</B> <A NAME="tex2html485" HREF="node8.html">Solving Puzzles</A>
<B>Up:</B> <A NAME="tex2html481" HREF="node3.html">User Guide</A>
<B>Previous:</B> <A NAME="tex2html475" HREF="node6.html">Creating Shapes</A>
&nbsp;<B><A NAME="tex2html483" HREF="node1.html">Contents</A></B> 
</BODY>
</HTML>
