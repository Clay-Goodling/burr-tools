<HTML>
<HEAD>
<TITLE>Solving Puzzles</TITLE>
</HEAD>

<BODY >
<B>Next:</B> <A NAME="tex2html513" HREF="node9.html">Reporting with BurrTools</A>
<B>Up:</B> <A NAME="tex2html509" HREF="node3.html">User Guide</A>
<B>Previous:</B> <A NAME="tex2html503" HREF="node7.html">Defining Puzzles</A>
&nbsp;<B><A NAME="tex2html511" HREF="node1.html">Contents</A></B> 
<HR>
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
  <LI><A NAME="tex2html514" HREF="node8.html#SECTION02510000000000000000">Solver Settings</A>
  <LI><A NAME="tex2html515" HREF="node8.html#SECTION02520000000000000000">Solving Puzzles</A>
  <UL>
    <LI><A NAME="tex2html516" HREF="node8.html#SECTION02521000000000000000">Automatic Solving</A>
    <UL>
      <LI><A NAME="tex2html517" HREF="node8.html#SECTION02521100000000000000">Solver Progress Information</A>
      <LI><A NAME="tex2html518" HREF="node8.html#SECTION02521200000000000000">Solver State Information</A>
    </UL>
    <LI><A NAME="tex2html519" HREF="node8.html#SECTION02522000000000000000">Manually Solving</A>
  </UL>
  <LI><A NAME="tex2html520" HREF="node8.html#SECTION02530000000000000000">Browsing Placements</A>
  <LI><A NAME="tex2html521" HREF="node8.html#SECTION02540000000000000000">Inspecting Results</A>
  <UL>
    <LI><A NAME="tex2html522" HREF="node8.html#SECTION02541000000000000000">Selecting Solutions and Animating Disassemblies</A>
    <LI><A NAME="tex2html523" HREF="node8.html#SECTION02542000000000000000">Handling Solutions</A>
    <LI><A NAME="tex2html524" HREF="node8.html#SECTION02543000000000000000">Visibility of Pieces</A>
  </UL>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION02500000000000000000"></A><A NAME="ChapterSolver"></A>Solving Puzzles</H1>
  
<P>
Solving puzzles is what B<SMALL>URR</SMALL>T<SMALL>OOLS</SMALL> is really about. Without its
  solving engine the program would be nothing more than a simple tool for
  drawing a very specific kind of 3-D objects... a task a lot of
  other software is no doubt even better suited for.

<P>
Solving puzzles is very straightforward with BurrTools even if the
  <I><B>Solver</B></I> tab (Figure
 <A HREF="#FigureSolver">Solver</A>) has quite a few controls. On top there is
  the <I>Parameters</I> panel that contains a list allowing you to select
  a specific problem to be solved, provides option settings for the solver,
  and has a series of buttons to direct the solving process. Finally, some
  information on the ongoing solving process is presented.
  
<CENTER>
<A NAME="FigureSolver"></A><A NAME="1794"></A>
<IMG SRC="Window_DDD_3.png"><BR>
<STRONG>Figure:</STRONG>Solving puzzles
</CENTER>

<P>
A second panel (<I>Solutions</I>) has the tools to browse the different
  solutions found, animate the moves to disassemble the puzzle to
  <EM>inspect</EM> the solutions in detail, and to organize the solutions that
  have been found.

<H1><A NAME="SECTION02510000000000000000">Solver Settings</A></H1>

<P>
In order to make the solver run, a problem must be selected first. A list of
  all previously defined problems is available right below the
  <I><B>Parameters</B></I> caption. Selecting problems to be solved
  is similar to selecting shapes, colours, or problems on the other tabs. Note
  that only the selected problem will be solved, and that solving one problem
  will preserve the results of any already solved or partially solved problem.
  Currently there are the following options for the solver. All deal with the
  kind of information the solver will report.

<P>
<DL>
<DT><STRONG><I>Solve Disassembly</I></STRONG></DT>
<DD>When checked, the solver will try to
    disassemble any assemblies found, and only those that indeed can be
    disassembled will be added to the list of solutions. If this option is
    left unchecked, the solver will merely search for all
    <EM>theoretically</EM> possible assemblies, i.e. assemblies for which the
    pieces do not overlap. Since solving disassemblies takes time (and often
    far more than assembling), it's recommended to leave this option unchecked
    for puzzles that always can be disassembled (e.g. P<SMALL>ENTOMINO</SMALL>
    problems and other packing problems). For that kind of puzzles, running
    the disassembler would only slow down the process without any gain in
    information.</DD>
<DT><STRONG><I>Just Count</I></STRONG></DT>
<DD>When checked, the solver will only count the
    number of solutions; it will drop the solutions right after they are
    found. Check this option if you're interested only in the number of
    solutions and not in the solutions themselves.</DD>
<DT><STRONG><I>Drop Disassm</I></STRONG></DT>
<DD>When checked, the program functions the
    same as with <I>Solve Disassembly</I> enabled, except that the
    disassembly is <EM>not</EM> stored, only the assemblies and some
    information <EM>about</EM> the disassemblies (like their level). This is
    useful if you have a problem that has many solutions and you want to find
    the most interesting solutions. Disassemblies take up a lot of memory
    within the computer so it is useful to just save some information while
    solving the puzzle and then later on, when everything is finished,
    recalculate the disassemblies for the interesting solutions.</DD>
<DT><STRONG>Keep Mirror Solutions</STRONG></DT>
<DD>When this box is checked, the program will
    not remove mirror solutions. Two solutions are mirror solutions are
    solutions when one solution is a real mirror of the other. This can happen
    only, when either all pieces are self mirroring (note that all flat pieces
    are self mirroring) or they have a mirror pair in the piece set. Sometimes
    it is possible to create the mirror solution by flipping the solution
    over. These are <EM>not</EM> mirror solutions to B<SMALL>URR</SMALL>T<SMALL>OOLS</SMALL> and
    are still removed. This option is useful when using piece ranges, as the
    mirror removal would remove too many solutions, like solutions with
    different piece sets.</DD>
<DT><STRONG>Sort by</STRONG></DT>

<DD>This option lets you choose the order in which
    the solutions are presented while the solver runs. There are 3
    possibilities:
<OL>
<LI>unsorted: The solutions are sorted in the order in which they were
      found.
<LI>by level: The solutions are sorted by the level. First by the
      number of moves to remove the first piece, if that is identical then by
      the moves for the second piece, and so on.
<LI>by number of moves to disassemble: The solutions are sorted by the
      sum of all moves required to completely disassemble the puzzle.
</OL>    
</DD>
</DT><STRONG>Drop</STRONG></DT>
<DD>If a puzzle has very many solutions, it might not
    be necessary or even possible to save all of them. E.g for polyomino-like
    puzzles it might be nice to keep just every 1000th of the millions of
    solutions, so as to have a profile of the possible solutions. Here you can
    specify every how many-th solution you want to keep. A 1 means you keep
    every solution, a 100 means you keep the first and the 101st and the 201st
    and so on.
</DD>
<DT><STRONG>Limit</STRONG></DT>
<DD>Limits the number of solutions to be saved. There
    will never be more than the specified number of solutions in the list.
    When the list is full the program has 2 choices:
    <OL>
<LI>Solutions are sorted: The programs throws away the solutions at
      the end. So low level solutions are removed.
<LI>Solutions are unsorted: The program starts to throw away every 2nd
      solution. So if you started with a drop-value of one and the list is
      full, the program starts to drop every 2nd solution it finds, and only
      adds every 2nd solution to the list. But for each added solution it also
      removes every 2nd solution that was already added to the list. After a
      while the list contains only every 2nd solution -- then the
      program only adds every 4th solution and removes again every 2nd
      solution that had been on the list, and so on. This sounds complicated
      but what is does is ensure you have an nice crossection of all the
      solutions, and not just the first or last N found.
</OL>    
</DD>
</DL>

<H1><A NAME="SECTION02520000000000000000">Solving Puzzles</A></H1>

<P>
Next to the solver options are some buttons to direct the solving process.
  Problems can be solved either in an automatic way or (manually)
  step-by-step.

<H2><A NAME="SECTION02521000000000000000">Automatic Solving</A></H2>

<P>
An automatic search will proceed until all solutions, i.e. assemblies and
  disassemblies (when requested), are found. To begin an automated search,
  click the <I><B>Start</B></I> button. Typically the solving
  process consists of a preparation phase followed by several cycles of
  assembling and disassembling. The latter is of course omitted when the
  <I>Solve Disassembly</I> option is left unchecked.

<P>
The automatic solving process can be interrupted by clicking
  <I><B>Stop</B></I>, but often the solver needs to finish some
  tasks first before it can actually halt
  (&rarr; <A HREF="#SolverInformation">Solver Information</A>). Any interrupted solving
  process can be saved to the puzzle file and be resumed in another session
  with B<SMALL>URR</SMALL>T<SMALL>OOLS</SMALL>. In fact, on loading such a partially solved
  puzzle B<SMALL>URR</SMALL>T<SMALL>OOLS</SMALL> will inform you about the possibility to
  continue with the search for solutions.

<P>
When the solver is interrupted, the shapes (&rarr; 
Chapter <A HREF="node6.html#ChapterShapes">Shapes</A>) and/or the problems (&rarr;
Chapter <A HREF="node7.html#ChapterPuzzles">Puzzles</A>) can be edited. If no editing whatsoever of these has
  been done, the solving process can be simply resumed
  (<I><B>Continue</B></I>), otherwise you need to start all over
  again. But keep in mind that the saving of the internal state of the solver
  is very version dependent. So it is likely that a new version of
  B<SMALL>URR</SMALL>T<SMALL>OOLS</SMALL> cannot resume solving a puzzle saved with an older
  version. So it is good practice to finish solving jobs with one version of
  B<SMALL>URR</SMALL>T<SMALL>OOLS</SMALL> before updating to the next.

<P>
When the solver is running it provides a lot of information about what it is
  doing and an estimate of the time it will need to finish the search. All
  this information is presented on six lines immediately below the solver
  control buttons (Figure
 <A HREF="#FigureSolverInformation">Solver Information</A>). Keep in mind that the estimated
  time to finish can be off by a very big amount. It happens often that the
  figure starts with ages and millennia and then the solving is finished
  within a few seconds, so be careful not to give up too soon.
  
<CENTER>
<A NAME="FigureSolverInformation"></A><A NAME="1810"></A>
<IMG SRC="SolverProgress.png"><BR>
<STRONG>Figure:</STRONG>The solver information
</CENTER>

<H3><A NAME="SECTION02521100000000000000">Solver Progress Information</A></H3>

<P>
The first line of the solver information is a progress bar indicating the
  percentage of work it has done. The fifth (<I><B>Time
  Used</B></I>) and the sixth (<I><B>Time Left</B></I>) line respectively
  show the time already spent on the search and an estimate of the time still
  needed to finish the solving process. Note that these are <EM>very rough
  estimates</EM> since these are based on the possible placements of the pieces
  already tested and still to test. However, the possible placements to be
  tested are constantly fluctuating as they are determined by the positions of
  previously placed pieces (&rarr; <A HREF="#BrowsingPlacements">Browsing Placements</A>).

<H3><A NAME="SECTION02521200000000000000"></A><A NAME="SolverInformation"></A>Solver State Information</H3>

<P>
Probably most important is the <I><B>Activity</B></I> and result
  information provided by the solver. The <I>Activity</I> line tells you
  not only what the solver is currently doing, but also whether the solver can
  be interrupted or not. The following is an overview of the activities of the
  solver:

<P>
<DL>
<DT><STRONG>nothing</STRONG></DT>
<DD>This indicates that the solver is ready to be started
    (provided a valid problem is selected) and that no information is
    available about earlier attempts to solve the selected problem.
</DD>
<DT><STRONG>prepare</STRONG></DT>
<DD>The solver is creating the internal data structure for the
    assembler. This structure is more or less a listing of all the possible
    places that all the pieces can go.
</DD>
<DT><STRONG>optimize piece <EM>n</EM></STRONG></DT>
<DD>In this second stage of the preparation,
    the placements for each piece are tested for plausibility. Some placements
    are just nonsense in that they result in unfillable holes or prevent the
    placement of other pieces. These placements are removed from the data
    structure (&rarr; <A HREF="#BrowsingPlacements">Browsing Placements</A>).
</DD>
<DT><STRONG>assemble</STRONG></DT>
<DD>The program is currently searching for assemblies.
</DD>
<DT><STRONG>disassemble</STRONG></DT>
<DD>An assembly was found and is now being tested for
    disasembability.
</DD>
<DT><STRONG>pause</STRONG></DT>
<DD>A search was started and interrupted.
</DD>
<DT><STRONG>finished</STRONG></DT>
<DD>The search has been completed, all the solutions found,
    ordered by the set up sorting criterium, can be inspected
    (&rarr; <A HREF="#InspectingResults">Inspecting Results</A>).
</DD>
<DT><STRONG>please wait</STRONG></DT>
<DD>The user wanted to stop the search, but the program
    still has to finish what it is doing right now. Only the assembler is
    interruptible. The preparation and optimisation stages need to be
    finished. The disassembly search also has to be finish before halting.
</DD>
<DT><STRONG>error</STRONG></DT>
<DD>Something is wrong with the puzzle and an error message,
    providing more specific information on the error, is usually displayed.
</DD>
</DL>

<P>
Finally, the solver gives information about the
  <I><B>Assemblies</B></I> found thus far (i.e. assemblies for which
  the pieces do not overlap in 3-D space) and
  <I><B>Solutions</B></I> or disassemblies (i.e. assemblies that
  also can be constructed in real life using the particular pieces of the
  puzzle). Note that the <I>Solutions</I> are reported (and in fact
  tested) only if the <I>Solve Disassembly</I> option is enabled.

<H2><A NAME="SECTION02522000000000000000">Manually Solving</A></H2>

<P>
Besides the automated search, <I>BurrTools</I> allows you to run the
  solver step-by-step. Note that this feature is still under construction and
  that it has a lot of shortcomings. For instance, it won't add the solutions
  it finds to the list or update the solver information. So it certainly needs
  a lot of improvements in a future release of the program. For the time being
  it is useful only to check the assembly process when something went wrong
  with the automated search.

<P>
A manual search needs the initial preparation phase as well as an automatic
  search. This can be accomplished by clicking
  <I><B>Prepare</B></I>. The solver will halt after this initial
  phase and the subsequent steps of the assembler can be seen in the
  3-D viewer by clicking the <I><B>Step</B></I> button.

<H1><A NAME="SECTION02530000000000000000"></A><A NAME="BrowsingPlacements"></A><BR>Browsing Placements</H1>

<P>
The <B><I>Browse Placements</I></B> button opens a window
  (Figure
 <A HREF="#FigurePlacementBrowser">Placement Browser</A>) that lets you examine the
  positions for each piece that will by tried by the assembler. The placements
  displayed in this window are the possible positions left in the current
  state of the assembler. So if the assembler has placed a piece S<EM>a</EM>
  and this prevents placing another piece S<EM>b</EM> at some positions, those
  positions of piece S<EM>b</EM> will <EM>not</EM> be visible in the list. If
  you want to see every placement tried, you have to either initialise a
  manual search (click the <I>Prepare</I> button), stop the assembler
  before is starts to do anything (click <I>Stop</I> while in preparation
  or optimisation stage), or wait until the assembler has finished its work.
  
<CENTER>
<A NAME="FigurePlacementBrowser"></A><A NAME="1821"></A>
<IMG SRC="Window_Placements.png"><BR>
<STRONG>Figure:</STRONG>Placement browser
</CENTER>

<P>
The <B><I>Placement Browser</I></B> window (Figure
  <A HREF="#FigurePlacementBrowser">Placement Browser</A>) has a very simple layout and consist mainly of
  a 3-D viewer and some additional scrollbars. This 3-D
  viewport, which shows the outline of the result shape and therein the shape
  for which the possible positions are to be analysed, behaves similar to the
  viewport in the main window. Drag the piece to rotate it in space and use
  the scrollbar on the right to zoom in or out.

<P>
Each piece in the problem (including each instance of a multipiece) can be
  selected with the scrollbar on top of the window. The left scrollbar allows
  browsing all the different placements for the selected piece. Both these
  scrollbars can also be controlled with the cursor keys on the keyboard:
  <TT>[Up]</TT> and [<TT>Down]</TT> for the left scrollbar and
  <TT>[Left]</TT> and <TT>[Right]</TT> to select the piece. Be careful
  though, the first stroke on the keyboard that doesn't fit the current
  scrollbar will just select the other one and the following keystroke will
  start to move the slider.

<H1><A NAME="SECTION02540000000000000000"></A><A NAME="InspectingResults"></A>Inspecting Results</H1>

<P>
As soon as any result is found, the solutions list becomes available on the
  <I><B>Solutions</B></I> panel and the 3-D viewer shows
  the first solution in the list. Note that subsequent solutions are simply
  added to that list, and that they can get sorted by the total number of
  moves (in case disassembly was requested) after the search is completed. All
  solutions that have been found can be inspected at any time, this does not
  interfere with the ongoing solving process. But completing the search and
  resetting the scrollbar for browsing the solutions may be needed to show the
  solutions properly ordered.

<P>
This panel has four components:
  
<UL>
<LI>a scrollbar (<I><B>Solution</B></I>) to browse the
    different solutions,
</LI>
<LI>a second scrollbar (<I><B>Move</B></I>) to view the moves
    involved in the disassembly,
</LI>
<LI>an array of buttons with very short labels to organize the solution
    list, and
</LI>
<LI>a list of all instances of the pieces in the puzzle problem, which
    allows you to alter their visibility in the solution(s).
</LI>
</UL>

<H2><A NAME="SECTION02541000000000000000">Selecting Solutions and Animating Disassemblies</A></H2>

<P>
By moving the slider of the top scrollbar
  (<I><B>Solution</B></I>), any solution from the list can be
  selected as is indicated by its number in the text box left of the it. Above
  the scrollbar there is an indication of the total number of solutions in the
  list. When the scrollbar is active it can also be controlled by the
  <TT>[Left]</TT> and <TT>[Right]</TT> cursor keys. Keep in mind that the
  number of solutions in the list may be different from the real number of
  solutions. The correct number of solutions for the problem is shown in the
  solver progress section.

<P>
The second scrollbar (<B><I>Move</I></B>) also has a text box on
  the left, this time reflecting the stage of disassembly (i.e. the number of
  moves executed in the disassembling process) of the currently selected
  solution. Moving the slider to the right will animate the disassembly,
  moving it to the left will reassemble the pieces in the 3-D
  viewer. Again, when activated the scrollbar can be controlled by the
  <TT>[Left]</TT> and <TT>[Right]</TT> cursor keys. Above this scrollbar
  is shown the <EM>total</EM> number of moves required for the disassembly,
  followed by the level(s) of the selected solution. Note that this scrollbar
  is visible only for solutions that have disassembly instructions available.

<P>
The position of the <I>Move</I> scrollbar isn't affected by selecting
  any other solution, and thus allows easily comparing the different solutions
  at a particular stage in the disassembly process.

<P>
Below the <I>Move</I> scrollbar are 2 fields that show you 2 numbers
  associated with the currently selected solution. The first is the assembly
  number and the second is the solution number. Both numbers define when a
  solution was found. The first assembly found gets assembly number one. But
  for example that one might not be disassembable so it gets thrown away. The
  second assembly found gets assembly number two, and if it is also
  disassembable it gets solution number 1. So you will see assembly 2 and
  solution 1 in these 2 fields for the given example.

<H2><A NAME="SECTION02542000000000000000">Handling Solutions</A></H2>

<P>
The big button group below the Solution selector and animator lets you
  modify the solutions. They are activated only when no solver is running.

<P>
With the buttons in the first row you can re-sort the solutions by the same
  criteria as you can select for the solver. You can sort them in the order
  they were found (unsorted) or by level or by sum of moves to completely
  disassemble and additionally be the pieces that are used in the solution.

<P>
The second row of buttons allows the deletion of certain solutions from the
  list.

<P>
<DL>
  <DD><I>[Del All] </I>removes all solutions</DD>
<DD><I>[Del Before] </I>removes all solution before the currently
    selected solution. The selected solution is the first one in the list that
    is not removed</DD>
    <DD><I>[Del At] </I>removes the currently selected solution</DD>
<DD><I>[Del After] </I>removes all solutions behind the currently
selected one. The selected on is the last one that is kept</DD>
<DD><I>[Del w/o DA] </I>remove all solutions that have no disassembly</DD>
</DL>

<P>
The last row of buttons allow the addition or removal of disassemblies to
  the list of puzzles.

<P>
<DL>
<DD><I>[D DA] </I>deletes the disassembly of the currently selected
    solution. The disassembly is replaced by data containing only information
    <EM>about</EM> the disassembly, so you can still sort the solutions</DD>
    <DD><I>[D A DA] </I>deletes all disassemblies</DD>
<DD><I>[A DA] </I>adds the disassembly to the currently selected
solution</DD>
<DD><I>[A A DA] </I>add the disassembly to all solutions. Already
existing disassemblies are thrown away</DD>
<DD><I>[A M DA] </I>add the disassembly to all solutions that do not
    have one. Solutions that already have a disassembly are left
    unchanged</DD>
</DL>

<H2><A NAME="SECTION02543000000000000000"></A><A NAME="VisibilityOfPieces"></A>Visibility of Pieces</H2>

<P>
In the list at the bottom of the <I>Solutions</I> panel, all pieces used
  in the problem are represented by their identifier. Instances of multipieces
  have a counter added to their prefix which now takes the form
  '<I><B>Sx.n</B></I>' and their default colour may be slightly
  modified to tell them apart.

<P>
By clicking an identifier, the visibility state of that particular piece is
  altered in the 3-D viewer. Each piece can have three states:
  <EM>visible</EM>, <EM>outlined</EM>, or <EM>invisible.</EM> Clicking an
  identifier repeatedly just cycles through these states and also alters the
  way the identifiers are depicted in the list. These features are very useful
  in designs for which the pieces are packed in a box, since the box would
  hide most of the action that is going on inside (e.g. A<SMALL>L </SMALL>P<SMALL>ACKINO</SMALL>,
  &rarr; Appendix <A HREF="node14.html#AppendixExamples">Examples</A>). Also they are very
  useful for inspecting the interaction of a few pieces and allow comparison
  between different solutions, as the visibility states remain invariant in
  selecting solutions.

<P>
Additionally it is possible to set the visibility state of a piece to
  invisible by pressing <TT>[Shift]</TT> and then clicking onto the piece in
  the 3-D viewer. This is handy when using custom colours and the default
  colour is not visible or when there are many pieces and the distinction by
  colour becomes hard.

<P>
By default the pieces that become separated from the rest gradually fade out
  during the final move. Sometimes this is unwanted as it may hinder a clear
  view on what's going on. This can be avoided by unchecking
  <B><I>Fade Out Pieces</I></B> on the options window (activated
  through <I><B>Config</B></I> on the menu bar).

<P>
As not all pieces are used in all solutions, the list of pieces shows only
  the names of those pieces that are really used in the currently selected
  assembly. All other boxes become very small and contain no name. This should
  help to quickly find out which pieces are used and which piece on screen
  corresponds to what item in the piece visibility selector.

<HR>
<B>Next:</B> <A NAME="tex2html513" HREF="node9.html">Reporting with BurrTools</A>
<B>Up:</B> <A NAME="tex2html509" HREF="node3.html">User Guide</A>
<B>Previous:</B> <A NAME="tex2html503" HREF="node7.html">Defining Puzzles</A>
&nbsp;<B><A NAME="tex2html511" HREF="node1.html">Contents</A></B> 
</BODY>
</HTML>
