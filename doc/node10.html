<HTML>
<HEAD>
<TITLE>Future Plans</TITLE>
</HEAD>

<BODY >
<B> Next:</B> <A NAME="tex2html549" HREF="node13.html">Appendices</A>
<B> Up:</B> <A NAME="tex2html545" HREF="node3.html">User Guide</A>
<B> Previous:</B> <A NAME="tex2html541" HREF="node9.html">Reporting with BurrTools</A>
&nbsp;<B><A NAME="tex2html547" HREF="node1.html">Contents</A></B> 
<HR>
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
  <LI>
  <UL>
    <LI><A NAME="tex2html550" HREF="node10.html#SECTION02701000000000000000">Burr Design Tools</A>
    <UL>
      <LI><A NAME="tex2html551" HREF="node10.html#SECTION02701100000000000000">Burr Constructing</A>
      <LI><A NAME="tex2html552" HREF="node10.html#SECTION02701200000000000000">Destruction</A>
      <LI><A NAME="tex2html553" HREF="node10.html#SECTION02701300000000000000">Burr Growing</A>
    </UL>
  </UL>
</UL>
<HR>

<H1><A NAME="SECTION02700000000000000000">Future Plans</A></H1>
  
<P>
So, what are our future plans? There are a lot of things still missing (or
  in need of improvements) from the current program. A list of things that
  might be interesting to implement are the following:
  
<UL>
<LI>Add some special algorithms that are faster for certain kind of
    puzzles. The current algorithm is quite good for nearly all puzzles, but
    it's not <EM>the</EM> fastest.
<LI>Add more colour constraint possibilities, e.g. edge matching, ...
<LI>Add more different space grids, add parameters to some grids
    (lengths and angles).
<LI>Add rotation checks to the disassembler.
<LI>Add a shape generator: create all piece shapes that fulfil certain
    rules (shape, colours, union of two shapes, ...)
<LI>Libraries of shapes to import pieces from.
<LI>Add tools for puzzle design (see below).
<LI>Make it possible to divide problems so that they can be solved in
    parallel on several computers and then the solutions are back together in
    one file.
<LI>Improve multi-threading so that multi-core CPUs are better used.
<LI>Better tool for colourization of a piece. E.g. checkering, but it
    needs to be more general than just checkering.
<LI>Create a debug window to make it possible to find out why there is
    no assembly or why an assembly can not be taken apart.
<LI>Speed improvements.
<LI>''Unificator'' a tool that makes it easy to check the results of
    adding color constraints. For example: suppose you have designed a puzzle
    with one interesting solution and many uninteresting ones and you want
    now, by adding color constrains, make that one solution unique. It can be
    a labor intensive task to do that. The unificator would help here by
    quickly showing the results of adding color here or making a piece that
    color, ...
<LI>exploded view
</UL>

<P>
We would be very happy to get contributions from other people. After all
  there are quite a few people out there that have their own puzzle solving
  programs, maybe they have some nice additions. There is one important thing
  to keep in mind: the additions have to run on L<SMALL>INUX</SMALL>. So you can
  not use any proprietary library that is not available for L<SMALL>INUX</SMALL>.

<H2><A NAME="SECTION02701000000000000000">Burr Design Tools</A></H2>

<P>
The following paragraphs are written as if the features were already
  implemented, but this is only done so that the text can be copied into the
  real book without having to rewrite a lot of it.

<P>
There are 3 possible design methods implemented in BurrTools

<OL>
<LI>BurrGrowing after Dic Sonnevelds ideas
<LI>Constructing, the natural approach
<LI>Destructing, the inverse way, take the assembled puzzle and try to
    assign cubes to one of the pieces
</OL>
  
The following sections will describe these methods

<H3><A NAME="SECTION02701100000000000000">Burr Constructing</A></H3>

<P>
The idea behind Constructing is to create new puzzles out of a set of
  pieces, try all possibilities and select the best found. To give the
  designer a great number of possibilities there are loooots of options here
  beginning with the design of the pieces ending with the method of how to
  solve the generated puzzle and how to save them.

<P>
The basis for the Burr Construction is a normal puzzle file containing some
  shapes. These shapes are then taken by the constructor and made into many
  puzzles that are solved.

<P>
So lets start with the piece generation. Each piece for the puzzle that
  needs to be generated may be assembled out of the following possibilities: a
  fixed piece, a list of pieces, a merger of 2 or more pieces, a piece
  containing variable cubes. The whole possibilities can be stacked on one
  another, so you can specify a list of 2 pieces where is piece is the merger
  of 3 pieces containing variable cubes... . All this can result in many
  possibilities, so be careful if you want a full analysis this side of
  eternity. Because of the complexity the program also might encounter the
  same puzzle several times. It will also be possible to let the program
  select puzzles out of the definition space by chance instead of doing a full
  analysis.

<P>
So what do the possibilities mean.

<P>

<DL>
<DT><STRONG>fixed piece</STRONG></DT>
<DD>a shape containing no variable cubes. This shape is
    directly used</DD>
<DT><STRONG>variable piece</STRONG></DT>
<DD>a shape containing n (n&gt;0) variable cubes. All
shapes are used that have one of the 2^n
 possible conditions for the
    variable cubes are used</DD>
<DT><STRONG>list of pieces</STRONG></DT>
<DD>the pieces in the list are taken one after the other</DD>
<DT><STRONG>merger of n pieces</STRONG></DT>
<DD>a new piece is constructed containing the union
    of both pieces, where the union is set, if one of more of the shapes to
    merge is set and the others are not set and variable is at least one is
    variable.</DD>
</DL>

<P>
At the end of the process it is possible to define the type of connection
  that must exists inside the shapes, shapes that do not fulfil this
  requirement are dropped

<P>
All these possibilities may lead to a huge number of shapes, so be careful.

<P>
Now it is possible to select the way the puzzle is solved. This includes
  disassembly (if or if not), also reduction and parameters for reduction can
  be set

<P>
Finally it is possible to select the way the created puzzles are saved.
  
<UL>
<LI>All / only Solvable / only uniquely
<LI>keep best with least number of solutions
<LI>keep best with highest disassembly level
<LI>keep best with biggest disassembly tree (most branches on the way
    out)
<LI>keep best with highest number of not disassembable solutions
</UL>

Save puzzles with solution(s) or without to save space

<P>
The puzzles are all saved into single directory, that must be selected

<P>
It would be nice to be able to stop the search process and continue later
  on, the parameters for the constructor should be saved into the source
  puzzle file (including the current state)

<P>

<H3><A NAME="SECTION02701200000000000000">Destruction</A></H3>

<P>
Destruction is in some way the inverse process of construction. Here you
  start with the finished assembly and you assign the outer voxels to certain
  pieces. Now the search process starts by assigning the not yet assigned
  cubes to pieces or to voids. All possibilities are tried and the best are
  kept.

<P>
Additionally it is possible to pose certain requirements on the piece
  shapes. You can say in which way the pieces must be connected (by faces,
  edges, corners), if the pieces need to be machine makable.

<P>
Also it is possible to do the whole process randomly instead of completely

<P>

<H3><A NAME="SECTION02701300000000000000">Burr Growing</A></H3>

<P>
This method has been pioneered by Dic Sonneveld. It is suitable to create
  extremely high level burrs. The algorithm works by adding cubes to pieces to
  prevent certain moves and hope that the puzzle will still be disassembable
  in a different way.

<P>
<HR>
<B>Next:</B> <A NAME="tex2html549" HREF="node13.html">Appendices</A>
<B>Up:</B> <A NAME="tex2html545" HREF="node3.html">User Guide</A>
<B>Previous:</B> <A NAME="tex2html541" HREF="node9.html">Reporting with BurrTools</A>
&nbsp;<B><A NAME="tex2html547" HREF="node1.html">Contents</A></B> 
</BODY>
</HTML>
